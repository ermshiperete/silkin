import java.util.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyVetoException;
import java.io.IOException;
import java.util.Iterator;
import javax.swing.*;
import static javax.swing.WindowConstants.DISPOSE_ON_CLOSE;

/**This is intended to allow an Anthropology Coordinator or an advanced user to
 *  browse through the SILKin library of known kinship systems. This tool is for
 * viewing, not editing. Editing the current Domain Theory is accomplished via
 * the {@link EditTheoryFrame} class.
 *
 *  @author		Gary Morris, Northern Virginia Community College
 *                              garymorris2245@verizon.net
 */
public class LibBrowser extends KSJInternalFrame {
    LibBrowser window = this;
    public static int serialNmbr = 1, factor = 7;
    public ArrayList<String> letterLegend = null;
    static MyResBundle se = Library.screenElements,
                       mi = Library.menuItems,    
                       msgs = Library.messages;
    DomThListener dtListener = new DomThListener();
    KinTermListener ktListener = new KinTermListener();
    ClauseListener cbListener = new ClauseListener();
    ExpListener xpListener = new ExpListener();
    PrimExtListener peListener = new PrimExtListener();
    DiagramButtonListener diaListener = new DiagramButtonListener();
    ChartComboListener chartListener = new ChartComboListener();
//    Runtime runner = Runtime.getRuntime();
    boolean langLoad = false, termLoad = false, clauseLoad = false, expLoad = false;
    Context currentContext;
    DomainTheory currentDomTh;
    KinTermDef currentKTD;
    ClauseBody currentOriginalHC, currentExpandedHC;
    String langName = "None", termName = "All", 
           priorLangPick;
    String[] comboItems;
    boolean inclPrim = true, inclExt = true,
            diagramExists = false;
    Individual currEgo;
    LibBrowserChart chart = new LibBrowserChart(this);
    ParserGEDCOM paul;
    TreeMap<String, ArrayList<Locatable>> chartEgos =
                new TreeMap<String, ArrayList<Locatable>>();
    /** dimensions stores the width and height of the diagrams to be painted
     *  on each chart. The String = chartID. The int array holds x,y (width, height).
     * 
     */public TreeMap<String, int[]> dimensions = 
             new TreeMap<String, int[]>();

    /**
     * Creates new LibBrowser2
     */
    public LibBrowser() {
        super(Library.screenElements.getString("browser#") + serialNmbr);
        windowNum = Library.screenElements.getString("browser#") + serialNmbr++;
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        MainPane.openBrowsers.add(this); 
        addInternalFrameListener(this);
        chart.noRefresh = true;
        initComponents();
        prepComponents();
        chart.noRefresh = false;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        rbPrimExt = new javax.swing.ButtonGroup();
        splitPane = new javax.swing.JSplitPane();
        original = new javax.swing.JScrollPane();
        originalText = new javax.swing.JTextArea();
        expanded = new javax.swing.JScrollPane();
        expandedText = new javax.swing.JTextArea();
        langPick = new javax.swing.JComboBox();
        bottomPane = new javax.swing.JScrollPane();
        diagram = new javax.swing.JTextArea();
        termPick = new javax.swing.JComboBox();
        rbPrim = new javax.swing.JRadioButton();
        rbExt = new javax.swing.JRadioButton();
        rbBoth = new javax.swing.JRadioButton();
        diagramIt = new javax.swing.JButton();
        clausePick = new javax.swing.JComboBox();
        expanPick = new javax.swing.JComboBox();
        chartComboBox = new javax.swing.JComboBox();
        printButton = new javax.swing.JButton();

        setClosable(true);
        setResizable(true);
        setTitle("Library Browser");
        setPreferredSize(new java.awt.Dimension(950, 658));

        splitPane.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        originalText.setColumns(20);
        originalText.setRows(5);
        original.setViewportView(originalText);

        splitPane.setTopComponent(original);

        expandedText.setColumns(20);
        expandedText.setRows(5);
        expanded.setViewportView(expandedText);

        splitPane.setBottomComponent(expanded);

        langPick.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        langPick.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose A Language"));
        langPick.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                langPickActionPerformed(evt);
            }
        });

        bottomPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        bottomPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        bottomPane.setAutoscrolls(true);

        diagram.setColumns(20);
        diagram.setRows(5);
        diagram.setText("   This is the Diagram area.");
        bottomPane.setViewportView(diagram);

        termPick.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        termPick.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose A Kin Term"));

        rbPrimExt.add(rbPrim);
        rbPrim.setText("Primary");

        rbPrimExt.add(rbExt);
        rbExt.setText("Extended");

        rbPrimExt.add(rbBoth);
        rbBoth.setSelected(true);
        rbBoth.setText("Both");

        diagramIt.setText("Diagram Examples");

        clausePick.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        clausePick.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose A Clause"));

        expanPick.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        expanPick.setBorder(javax.swing.BorderFactory.createTitledBorder("Choose Expansion"));

        chartComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        printButton.setText("Print");
        printButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                printButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(bottomPane, javax.swing.GroupLayout.PREFERRED_SIZE, 914, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(langPick, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(termPick, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(51, 51, 51)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(rbExt)
                                            .addComponent(rbPrim)
                                            .addComponent(rbBoth)))
                                    .addComponent(expanPick, javax.swing.GroupLayout.Alignment.TRAILING, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(clausePick, javax.swing.GroupLayout.Alignment.TRAILING, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(3, 3, 3))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(40, 40, 40)
                                .addComponent(printButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                        .addComponent(splitPane, javax.swing.GroupLayout.PREFERRED_SIZE, 736, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(53, 53, 53))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(diagramIt, javax.swing.GroupLayout.PREFERRED_SIZE, 171, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(152, 152, 152)
                        .addComponent(chartComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 348, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(splitPane, javax.swing.GroupLayout.PREFERRED_SIZE, 348, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(langPick, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(termPick, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbPrim)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbExt)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rbBoth)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(clausePick, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(expanPick, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(printButton)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(diagramIt)
                    .addComponent(chartComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bottomPane, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(47, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void prepComponents() {
        //  Menu for "Choose A Language"
        String[] langs = Library.genLangMenu();
        langPick.setModel(new DefaultComboBoxModel(langs));
        langPick.addActionListener(dtListener); 
        langPick.setBorder(BorderFactory.createTitledBorder(
                              BorderFactory.createLineBorder(Color.black), 
                              se.getString("chooseLang")));
        
        //  Items for Chart Combo Box
        DefaultComboBoxModel chartModel = new DefaultComboBoxModel(new String[] 
            { "A: Blank Chart", "Edit Chart Descriptions"});
        chartComboBox.setModel(chartModel);
        chartComboBox.addActionListener(chartListener);
         
        //  Menu for "Choose a Kinship Term"
        termPick.setModel(new DefaultComboBoxModel());
        termPick.addActionListener(ktListener);  
        termPick.setBorder(BorderFactory.createTitledBorder(
                                BorderFactory.createLineBorder(Color.black), 
                                se.getString("chooseKT")));
        
        //  Menu for "Choose a Clause Number"
        clausePick.setModel(new DefaultComboBoxModel());
        clausePick.addActionListener(cbListener);  
        clausePick.setBorder(BorderFactory.createTitledBorder(
                                BorderFactory.createLineBorder(Color.black), 
                                se.getString("chooseClause")));
        
        //  Menu for "Choose an Expansion Number"
        expanPick.setModel(new DefaultComboBoxModel());
        expanPick.addActionListener(xpListener);   
        expanPick.setBorder(BorderFactory.createTitledBorder(
                                BorderFactory.createLineBorder(Color.black), 
                                se.getString("chooseExpansion")));
        
        // Set actions for the 3 radio buttons
        rbPrim.setActionCommand("Primary");
        rbPrim.addActionListener(peListener);
        rbPrim.setText(se.getString("primary"));
        rbExt.setActionCommand("Extended");
        rbExt.addActionListener(peListener);
        rbExt.setText(se.getString("extended"));
        rbBoth.setActionCommand("Both");
        rbBoth.setSelected(true);
        rbBoth.addActionListener(peListener);
        rbBoth.setText(se.getString("both"));
        
        // Set up button for diagrams        
        diagramIt.setText(se.getString("diagramExamples"));
        diagramIt.addActionListener(diaListener);
        diagramIt.setActionCommand("diagram examples");
        diagramIt.setEnabled(true);
        
        //  Re-label Print button
        printButton.setText(mi.getString("print"));
        
        //  Prepare the Diagram area
        bottomPane.setPreferredSize(new Dimension(400, 250));
        bottomPane.setViewportView(chart);
        chart.setBackground(Color.white);
        
        //  Make a blank diagram with label
        chart.writeLtrLegend = false;
        chart.textContent = "    " + msgs.getString("diagramArea");
        chart.repaint();        
    }

    /**Erase (delete) any persons or families that may have been created during
     * background processing.
     * 
     * @param resetInd  serial number of the last person to be preserved
     * @param resetFam  serial number of the last family to be preserved 
     */
    public void reset(int resetInd, int resetFam) {
        try {
            Context.current.resetTo(resetInd, resetFam);
        } catch (KSInternalErrorException ouch) {
            JOptionPane.showMessageDialog(desktop,
                    msgs.getString("corruptedData") + ouch
                    + msgs.getString("sendBugReport"),
                    msgs.getString("seriousError"),
                    JOptionPane.ERROR_MESSAGE);
        }
    }  //  end of method reset
    
    public JTextArea getOriginalText() {
        return originalText;
    }
    
    public JScrollPane getOriginal() {
        return original;
    }
    public JTextArea getExpandedText() {
        return expandedText;
    }
    
    public JScrollPane getExpanded() {
        return expanded;
    }
    
    public String getCurrentComboSelection() {
        return (String) chartComboBox.getSelectedItem();
    }
    
    /**Allow access to this private field.
     * 
     * @return comboItems
     */
    public String[] getComboBoxItems() {
        return comboItems;
    }
    
    public String getClausePickSelection() {
        return (String) clausePick.getSelectedItem();
    }
    
    public String getExpandPickSelection() {
        return (String) expanPick.getSelectedItem();
    }
    
    public String getTermPickSelection() {
        return (String) termPick.getSelectedItem();
    }
    
    public boolean includePrimary() {
        if (rbBoth.isSelected() || rbPrim.isSelected()) {
            return true;
        }
        return false;
    }
    
    public boolean includeExtended() {
        if (rbBoth.isSelected() || rbExt.isSelected()) {
            return true;
        }
        return false;
    }
    
    /**
     * 
     * @param list 
     */
    public void diagramTerms(ArrayList<TermTriple> list) {
        reset(0, 0);
        letterLegend = null;
        chart.noRefresh = true;
        makeEgo();  //  Make a bag = 1 ego, for use in cb.generateExamples
        ArrayList<Object> egoBag = new ArrayList<Object>();
        egoBag.add(currentContext.individualCensus.get(0));
        ClauseBody cb = null;
        ArrayList<Object> pile = new ArrayList<Object>();
        for (TermTriple trip : list) {
            KinTermDef ktd = (KinTermDef) currentDomTh.theory.get(trip.kinTerm);
            //  If the base and exp fields mean "all" and "all" we simply add all
            //  the expandedDefs to the pile.
            if (trip.baseClauseNmbr + trip.expClauseNmbr == -2) {  //  -1 == All
                pile.addAll(ktd.expandedDefs);
            }
            //  If the exp field specifies a particular expandedDef, add that
            else if (trip.expClauseNmbr >= 0) {
                pile.add(ktd.expandedDefs.get(trip.expClauseNmbr));
            }
            //  Only other possibility is a specified base clause and ALL expansions
            else {
                cb = (ClauseBody) ktd.definitions.get(trip.baseClauseNmbr);
                for (Object o : ktd.expandedDefs){
                    ClauseBody expCB = (ClauseBody) o;
                    if (expCB.isExpansionOf(cb)) {
                        pile.add(expCB);
                    }
                }
            }
        }  //  End of loop thru list. Now pile contains all CB's we want to diagram.
           //  Now go thru the pile, unify variables & create examples
        try {
            ArrayList<Object> round2 = new ArrayList<Object>();
            for (int j = 0; j < pile.size(); j++) {
                cb = (ClauseBody) pile.get(j);
                cb.unifyVariables();
                if (cb.flags.contains("chooseLast")) {
                    round2.add(cb);
                } else {
                    Library.parseClauseCounterOn = false;
                    cb.generateExamples(currentContext, egoBag, null, null);
                }
            }
            MainPane.fill_In_Flag = true;
            for (int j = 0; j < round2.size(); j++) {  //  in Round 2, process delayed-ID terms
                cb = (ClauseBody) round2.get(j);
                cb.generateExamples(currentContext, egoBag, null, null);
            }
            MainPane.fill_In_Flag = false;
            for (Individual i : currentContext.individualCensus) {
                if (i.node == null) {    // make sure each ind has a node
                    i.node = new Node(); // to post a kinTerm on
                }
            }
            for (int i = 0; i < egoBag.size(); i++) {
                Individual ego = (Individual) egoBag.get(i);
                //  Tidy up the kinTerms of any extra folks in the diagram
                currentDomTh.fillInNames(ego);
            }
        } catch (KSBadHornClauseException bhc) {
            String msg = msgs.getString("constraintLogicalError1") + " " + bhc
                    + msgs.getString("constraintLogicalError2");
            JOptionPane.showMessageDialog(desktop, msg,
                    msgs.getString("badHornClause"),
                    JOptionPane.ERROR_MESSAGE);
            reset(0, 0);
            if (MainPane.activity == null) {
                MainPane.createActivityLog(desktop, menuView);
            }
            MainPane.activity.log.append("For clause: " + cb + "\n" + msg + "\n\n");
            return;
        } catch (KSConstraintInconsistency ci) {
            String msg = msgs.getString("constraintInconsistency1") + ci
                    + msgs.getString("constraintInconsistency2");
            JOptionPane.showMessageDialog(desktop, msg,
                    msgs.getString("constraintInconsistency"),
                    JOptionPane.ERROR_MESSAGE);
            reset(0, 0);
            if (MainPane.activity == null) {
                MainPane.createActivityLog(desktop, menuView);
            }
            MainPane.activity.log.append("For clause: " + cb + "\n" + msg + "\n\n");
            return;
        } catch (ClassNotFoundException ouch) {
            String msg = msgs.getString("classHandlingError") + ouch
                    + msgs.getString("sendBugReport");
            JOptionPane.showMessageDialog(desktop, msg,
                    msgs.getString("seriousError"),
                    JOptionPane.ERROR_MESSAGE);
            reset(0, 0);
            if (MainPane.activity == null) {
                MainPane.createActivityLog(desktop, menuView);
            }
            MainPane.activity.log.append("In: " + cb + "\n" + msg + "\n\n");
            return;
        } catch (KSInternalErrorException ouch) {
            String msg = msgs.getString("literalHandlingError") + ouch
                    + msgs.getString("sendBugReport");
            JOptionPane.showMessageDialog(desktop, msg,
                    msgs.getString("seriousError"),
                    JOptionPane.ERROR_MESSAGE);
            reset(0, 0);
            if (MainPane.activity == null) {
                MainPane.createActivityLog(desktop, menuView);
            }
            MainPane.activity.log.append("In: " + cb + "\n" + msg + "\n\n");
            return;
        }  //  end of Exception Catch blocks
        
        boolean addr = currentDomTh.addressTerms;
        Object[] options = new Object[2];
        if (addr) {
            options[0] = mi.getString("kinTermAdr");
            options[1] = mi.getString("letterAdr");
        } else {
            options[0] = mi.getString("kinTermRef");
            options[1] = mi.getString("letterRef");
        }
        int choice1 = JOptionPane.showOptionDialog(desktop,
                msgs.getString("labelingOptions"),
                msgs.getString("kinTermLabels"),
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null, //don't use a custom Icon
                options, //the titles of buttons
                options[0]); //default is full kin term
        if (choice1 == JOptionPane.YES_OPTION) {
            chart.kinTermLabel = (addr ? Person.KINTERMADR : Person.KINTERMREF);
            chart.writeLtrLegend = false;
        } else {
            chart.kinTermLabel = (addr ? Person.LETTERADR : Person.LETTERREF);
            letterLegend = makeLegend();        
            chart.writeLtrLegend = true;

        }// Now diagram it            
        //  Call layout code from GEDCOM parser
        boolean holdValue = chart.writeLtrLegend;
        paul = new ParserGEDCOM(currentContext);
        currentContext.chartDescriptions.clear();
        paul.assignChartAndLevel();
//        printPopulation();  //  Only for debugging
        paul.processChartRows();
        TreeMap<String, Integer> spacerMap = new TreeMap<String, Integer>();
        computeHorizontalCushions(spacerMap);
        paul.expandToGridUnits(spacerMap);
        narrowSpaceAroundFamilies(spacerMap);
        computeDiagramSizes(spacerMap);
        reloadChartComboBox();
//        printPopulation();
        //  Now paint the diagram area with all Ind,Fam, and Link objects.
        chart.nameLabel = Person.LAST;  // Controls labeling of each symbol
        chart.currentContext = currentContext;
        chart.chartID = "A";
        int[] dims = dimensions.get("A");
        if (dims == null) {
            return;
        }
        chart.width = dims[0];
        chart.height = dims[1];
        chart.offsetX = 0;
        chart.writeLtrLegend = holdValue;  //  reloading combo box resets it
        chart.noRefresh = false;
        chart.repaint();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     chart.repaint();
        bottomPane.scrollRectToVisible(new Rectangle(0,0,200,200));
        diagramExists = true;
    }
    
    void printPopulation() {  //  for debugging only
        System.out.println("I# \tChart \tBF# \tMars");
        for (Individual ind : currentContext.individualCensus) {
            System.out.print(ind.serialNmbr + "\t" + ind.homeChart + "\t");
            if (ind.birthFamily != null) {
                System.out.print(ind.birthFamily.serialNmbr + "\t");
            } else {
                System.out.print("None\t");
            }
            for (Object o : ind.marriages) {
                System.out.print(((Family)o).serialNmbr + "\t");
            }
            System.out.println();
        }
        System.out.println("==============================\n\n");
    }
    
    public ArrayList<String> makeTermsUsed() {
        ArrayList<String> terms = new ArrayList<String>();
        ArrayList<Object> bagOfTerms = new ArrayList<Object>();
        for (Individual ind : currentContext.individualCensus) {
            bagOfTerms.addAll(ind.node.kinTermsRef);
            bagOfTerms.addAll(ind.node.kinTermsAddr);
            bagOfTerms.addAll(ind.node.extKinTermsRef);
            bagOfTerms.addAll(ind.node.extKinTermsAddr);
            for (Object o : bagOfTerms) {
                String term = (String) o;
                if (! term.equals("Ego") && ! terms.contains(term)) {
                    terms.add(term);
                }
            }
            bagOfTerms.clear();
        }  //  end of loop thru individuals    
        return terms;
    }
    
    public ArrayList<String> makeLegend() {
        TreeMap<String, String> letters = currentDomTh.getKTSymbols();
        ArrayList<String> legend = new ArrayList(),
                          termsUsed = makeTermsUsed();
        legend.add(msgs.getString("letterCodes"));
        for (Map.Entry pair : letters.entrySet()) {
            String term = (String) pair.getKey(),
                   ltr = (String) pair.getValue(),
                   middle = (ltr.length() > 1 ? " = " : "   = ");
            if (termsUsed.contains(term)) {
                legend.add(ltr + middle + term);
            }
        }
        return legend;
    }

    /**
     * Loop through all Individuals and LInks in every chart to
     * determine the longest (series of) kin term(s) under a symbol. This will
     * determine how much horizontal space must be allowed between symbols on
     * that chart.
     *
     * Build the results in spacerMap; it will be used by other methods later.
     *
     * @param spacerMap a TreeMap of ChartID -> spacing
     */
    public void computeHorizontalCushions(TreeMap<String, Integer> spacerMap) {
        // There will be kinTerms in either kinTermsRef or kinTermsAddr,
        // but not both. By side effect, fill in the chartEgos TreeMap.
        int cushion = 0;
        Integer zero = new Integer(0);
        String chID;
        chartEgos.clear();
        for (Link lk : currentContext.linkCensus) {
            if (!lk.deleted) {
                chID = lk.homeChart;
                if (chartEgos.get(chID) == null) {
                    chartEgos.put(chID, new ArrayList<Locatable>());
                }
                chartEgos.get(chID).add(lk);
            }
        }  //  end of loop thru Links
        for (Individual p : currentContext.individualCensus) {
            if (p != null && !p.deleted) {
                cushion = Library.gridX;
                chID = p.homeChart;
                if (!chID.isEmpty()) {
                    if (p.name.equals("Ego")) {
                        p.node.kinTermsRef.add("Ego");
                        p.node.kinTermsAddr.add("Ego");
                        if (chartEgos.get(chID) == null) {
                            chartEgos.put(chID, new ArrayList<Locatable>());
                        }
                        chartEgos.get(chID).add(p);
                        if (spacerMap.get(chID) == null) {
                            spacerMap.put(chID, zero);
                        }
                    } else {  //  Not an Ego
                        int product = 0;
                        if (chart.kinTermLabel > 2) {  // Use Letters
                            for (Object o : p.node.kinTermsRef) {
                                product += (3 * factor) + 5;
                            }  //  3 = a letter, a comma, and a space
                            cushion = Math.max(product - 2, cushion);
                            product = 0;
                            for (Object o : p.node.kinTermsAddr) {
                                product += (3 * factor) + 5;
                            }
                            cushion = Math.max(product - 2, cushion);
                            if (spacerMap.get(chID) == null) {
                                spacerMap.put(chID, zero);
                            }
                        } else {   //  Use actual Kin Terms
                            for (Object o : p.node.kinTermsRef) {
                                product += (((String) o).length() * factor) + 5;
                            }
                            cushion = Math.max(product - 2, cushion);
                            product = 0;
                            for (Object o : p.node.kinTermsAddr) {
                                product += (((String) o).length() * factor) + 5;
                            }
                            cushion = Math.max(product - 2, cushion);
                            if (spacerMap.get(chID) == null) {
                                spacerMap.put(chID, zero);
                            }
                        }
                    }  //  end of not-an-ego
                    cushion = Math.max((Integer) spacerMap.get(chID), cushion);
                    spacerMap.put(chID, new Integer(cushion));
                    p.name = "I-" + p.serialNmbr;
                }  //  end of chartID is not null
            }  //  end of non-null & not deleted
        }  //  end of loop thru Individuals
        //  Default spacing (gridX = 40) allows for 6 characters of label             
    }
        
        /**Take symbols spaced uniformly apart, and narrow the horizontal space
         * occupied by families, that have no kin terms or names under them. 
         * 
         * APPROACH: On each chart, arrange the symbols (Locatables) from top to
         * bottom, left to right. Then for each family symbol reduce the horizontal 
         * space between it and a Link or Individual to a minimal standard width. 
         * Each reduction must be applied to every symbol to its right, cumulatively. 
         */
        public void narrowSpaceAroundFamilies(TreeMap<String, Integer> spacerMap) {
            TreeMap<String, TreeMap<Integer, TreeMap<Integer, Locatable>>> 
                    allCharts = new TreeMap<String, TreeMap<Integer, 
                            TreeMap<Integer, Locatable>>>();
            sortSymbols(allCharts);  // Sort all symbols by chart, by row, left to right
            Iterator chartIter = allCharts.entrySet().iterator();
            while (chartIter.hasNext()) {
                Map.Entry chEntry = (Map.Entry) chartIter.next();
                String chartID = (String) chEntry.getKey();
                int reducer = (spacerMap.get(chartID).intValue() - Library.gridX) / 2;
                if (reducer > 0) {  // skip this chart if no reduction needed
                    TreeMap<Integer, TreeMap<Integer, Locatable>> chartPage = (TreeMap<Integer, TreeMap<Integer, Locatable>>) chEntry.getValue();
                    Iterator rowIter = chartPage.values().iterator();
                    Locatable priorSymb = null;
                    while (rowIter.hasNext()) {
                        TreeMap<Integer, Locatable> 
                                row = (TreeMap<Integer, Locatable>) rowIter.next();
                        int cumRowReduction = 0;
                        Iterator symbolIter = row.entrySet().iterator();
                        while (symbolIter.hasNext()) {
                            Map.Entry symbolEntry = (Map.Entry) symbolIter.next();
                            int x = ((Integer) symbolEntry.getKey()).intValue();
                            Locatable symb = (Locatable) symbolEntry.getValue();
                            int symbCumReduction = 0;
                            //  Now reduce if symb is -- or is next to -- a Family symbol
                            int marriageReduction = 0;
                            if (priorSymb != null
                                    && (priorSymb instanceof Family || symb instanceof Family)) {
                                marriageReduction = reducer;
                            }
                            symbCumReduction = cumRowReduction + marriageReduction;
                            cumRowReduction = symbCumReduction;
                            x -= symbCumReduction;
                            symb.setLocationX(x);
                            priorSymb = symb; 
                        }  //  end of processing symbols                       
                    }  //  end of processing rows
                }  //  end of reducer was greater than zero
            }  // end of processing charts
            // Now go adjust BirthGroup locations in each Family
            for (Family fam : currentContext.familyCensus) {
                for (Marriage.BirthGroup bg : fam.birthGrps) {
                    int count = 0, sum = 0;
                    for (Individual ind : bg.members) {
                        count++;
                        sum += ind.getLocationX();
                    }
                    bg.topPtX = sum / count;
                } 
            }
        }  //  end of method narrowSpaceAroundFamilies
        

        /** Fill allCharts with the symbols in all the charts, sorted by
         *  chart, row, and x-coordinate. If a symbol is encountered with
         *  no homeChart, skip it (it is a singleton).
         * 
         * @param allCharts an empty TreeMap into which we'll sort the symbols
         */
        public void sortSymbols(TreeMap<String, TreeMap<Integer, TreeMap<Integer, Locatable>>> 
                    allCharts) {
            String chartID;
            for (Link lk : currentContext.linkCensus) {
                chartID = lk.homeChart;
                if (chartID.isEmpty()) {
                    continue;
                }
                if (allCharts.get(chartID) == null) {
                    allCharts.put(chartID, 
                            new TreeMap<Integer, TreeMap<Integer, Locatable>>());
                }
                Integer x = new Integer(lk.getLocationX()),
                        y = new Integer(lk.getLocationY());
                if (allCharts.get(chartID).get(y) == null) {
                    allCharts.get(chartID).put(y, new TreeMap<Integer, Locatable>());
                }
                //  lk is the only symbol at that location
                allCharts.get(chartID).get(y).put(x, lk);
            }
            for (Individual ind : currentContext.individualCensus) {
                chartID = ind.homeChart;
                if (chartID.isEmpty()) {
                    continue;
                }
                if (allCharts.get(chartID) == null) {
                    allCharts.put(chartID, 
                            new TreeMap<Integer, TreeMap<Integer, Locatable>>());
                }
                Integer x = new Integer(ind.getLocationX()),
                        y = new Integer(ind.getLocationY());
                if (allCharts.get(chartID).get(y) == null) {
                    allCharts.get(chartID).put(y, new TreeMap<Integer, Locatable>());
                }
                //  ind is the only symbol at that location
                allCharts.get(chartID).get(y).put(x, ind);
            }
            for (Family fam : currentContext.familyCensus) {
                chartID = fam.homeChart;
                if (chartID.isEmpty()) {
                    continue;
                }
                if (allCharts.get(chartID) == null) {
                    allCharts.put(chartID, 
                            new TreeMap<Integer, TreeMap<Integer, Locatable>>());
                }
                Integer x = new Integer(fam.getLocationX()),
                        y = new Integer(fam.getLocationY());
                if (allCharts.get(chartID).get(y) == null) {
                    allCharts.get(chartID).put(y, new TreeMap<Integer, Locatable>());
                }
                //  fam is the only symbol at that location
                allCharts.get(chartID).get(y).put(x, fam);
            }
            // AllCharts is now sorted by chart, row, and x-coordinate
        }
        
        public void computeDiagramSizes(TreeMap<String, Integer> spacerMap) {
            int newWidth, newHeight;
            int[] newList = null;
            dimensions.clear();
            for (Family fam : currentContext.familyCensus) {
                if (dimensions.get(fam.homeChart) == null) {
                    newList = new int[] {0,0};
                    dimensions.put(fam.homeChart, newList);
                }
                newList = dimensions.get(fam.homeChart);
                newWidth = fam.location.x;
                newHeight = fam.location.y;
                newList[0] = Math.max(newWidth, newList[0]);
                newList[1] = Math.max(newHeight, newList[1]);
            }  //  end of loop thru families
            
            for (Link lk : currentContext.linkCensus) {
                if (dimensions.get(lk.homeChart) == null) {
                    newList = new int[] {0,0};
                    dimensions.put(lk.homeChart, newList);
                }
                newList = dimensions.get(lk.homeChart);
                newWidth = lk.location.x;
                newHeight = lk.location.y;
                newList[0] = Math.max(newWidth, newList[0]);
                newList[1] = Math.max(newHeight, newList[1]);
            }  //  end of loop thru links
            
            for (Individual ind : currentContext.individualCensus) {
                if (dimensions.get(ind.homeChart) == null) {
                    newList = new int[] {0,0};
                    dimensions.put(ind.homeChart, newList);
                }
                newList = dimensions.get(ind.homeChart);
                newWidth = ind.location.x;
                newHeight = ind.location.y;
                newList[0] = Math.max(newWidth, newList[0]);
                newList[1] = Math.max(newHeight, newList[1]);
            }  //  end of loop thru individuals    
            if (letterLegend != null && !letterLegend.isEmpty()) {
                int sz = letterLegend.size(),
                    extra = (sz < 11 ? sz : (sz + 1) / 2);
                for (Map.Entry entry : dimensions.entrySet()) {
                    newList = (int[]) entry.getValue();
                    newList[1] += (extra * 15) + 10;
                }                
            }  //  adding length of legend at bottom of chart
            
            // spacerMap and dimensions have both been built by looping
            // thru the same populations, so size must be equal and
            // the keys (chartIDs) must match.
            // We add the width and height of a symbol plus a border
            // to each x,y pair
            for (Map.Entry entry : spacerMap.entrySet()) {
                String chID = (String) entry.getKey();
                int spacer = ((Integer)entry.getValue()).intValue();
                dimensions.get(chID)[1] += spacer + 10;
                dimensions.get(chID)[0] += 60;
            }
        }  //  end of computeDiagramSizes()
        
        /**Rebuild the drop-down ComboBox of charts for th current diagram.
         * If there is an Ego on that chart page, give a title indicating a
         * male or female Ego. If there's a Link on that chart page, give title
         * showing what chart the link connects to.
         */
        public void reloadChartComboBox() {
            String chNmbr;
            ArrayList<Locatable> egoList;
            Locatable reason;
            Individual ind;
            comboItems = new String[chartEgos.size() +1];
            int ndx = 0;
            Iterator chIter = chartEgos.entrySet().iterator();
            while (chIter.hasNext()) {
                Map.Entry ch = (Map.Entry)chIter.next();
                chNmbr = (String) ch.getKey();
                egoList = (ArrayList<Locatable>) ch.getValue();
                reason = getBestRep(egoList);
                String item = chNmbr + ": ";
                if (reason instanceof Individual) {
                    ind = (Individual)reason;
                    item += (ind.gender.equals("M") ? 
                            se.getString("maleEgo") : se.getString("femaleEgo"));
                } else {
                    ind = ((Link)reason).personPointedTo;
                    item += "I-" + ind.serialNmbr + mi.getString("linkedFromChart") 
                            + ind.homeChart;
                }
                comboItems[ndx++] = item;
            }
            comboItems[ndx] = mi.getString("editDescr");
            chartComboBox.setModel(new DefaultComboBoxModel(comboItems));
            chartComboBox.setSelectedIndex(0);
        }
        
        Locatable getBestRep(ArrayList<Locatable> list) {
            Locatable best = list.get(0);  // default value
            Locatable bestPerson = null,
                      bestLink = null;
            for (Locatable loc : list) {
                if (loc instanceof Individual) {
                    if (bestPerson == null) {
                        bestPerson = loc;
                    } else {
                        Individual bestInd = (Individual) bestPerson,
                                newInd = (Individual) loc;
                        if (newInd.serialNmbr < bestInd.serialNmbr) {
                            bestPerson = loc;
                        }
                    }
                } else { // it must be a link
                    if (bestLink == null) {
                        bestLink = loc;
                    } else {
                        Link bestLk = (Link) bestLink,
                                newLink = (Link) loc;
                        if (newLink.serialNmbr < bestLk.serialNmbr) {
                            bestLink = loc;
                        }
                    }
                }
            }
            if (bestPerson != null) {
                return bestPerson;
            } else if (bestLink != null) {
                return bestLink;
            }
            return best;
        }

    /**
     * Ask User to choose the gender of Ego. Then create him or her. They will
     * automatically be added to the individualCensus of the current Context.
     *
     */
    public void makeEgo() {
        String sex = "M";
        Object[] options2 = {se.getString("male"),
            se.getString("female")};
        int choice1 = JOptionPane.showOptionDialog(desktop,
                se.getString("primaryEgoMaleOrFemale"),
                se.getString("settingGenderEgo"),
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null, //don't use a custom Icon
                options2, //the titles of buttons
                options2[0]); //default is Male
        if (choice1 == JOptionPane.YES_OPTION) {
            sex = "M";
        } else {
            sex = "F";
        }
        Individual ego = new Individual("Ego", sex);
        ego.setDateOfBirth("1970-01-01");
        if (currentDomTh.addressTerms) {
            ego.node.kinTermsAddr.add("Ego");
        } else {
            ego.node.kinTermsRef.add("Ego");
        }
        DomainTheory.addrTerms = currentDomTh.addressTerms;
        DomainTheory.current = currentDomTh;
    }  //  end of method makeEgo

        
         
    // This method inserts line breaks into Java-generated error messages.
    public String prettify(String ugly) {
        int start = 0, stop = 100, length = ugly.length(), 
                    period, comma, leftSquare, rightSquare, rightSquareComma, max;
        String lessUgly = null;
        while (stop < length)  {
            period = ugly.substring(start, stop - 10).lastIndexOf(".") + 1 + start;
            comma = ugly.substring(start, stop - 10).lastIndexOf(",") + 1 + start;
            rightSquare = ugly.substring(start, stop).lastIndexOf("]") + 1 + start;
            rightSquareComma = ugly.substring(start, stop).lastIndexOf("],") + 2 + start;
            leftSquare = ugly.substring(start, stop).lastIndexOf("[") + start;
            max = Math.max(comma, period);
            max = Math.max(max, leftSquare);
            max = Math.max(max, rightSquare);
            max = Math.max(max, rightSquareComma);
            if (max > (start + 60)) stop = max;
            lessUgly += ugly.substring(start, stop) + "\n";
            start = stop;
            stop += 100;
        }  //  end of while stop<length
        lessUgly += ugly.substring(start);
        return lessUgly;
    }  //  end of method prettify
    
    public void refreshLangMenu()  {
        String[] langs = Library.genLangMenu();
        langLoad = true;
        Library.currentLanguage = (String)langPick.getSelectedItem();
        langPick.removeAllItems();
        for (int i=0; i < langs.length; i++) langPick.addItem(langs[i]);
        langPick.setSelectedItem(Library.currentLanguage);
        langLoad = false;
    }
    
    
    private void langPickActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_langPickActionPerformed
        // Not needed. DomThListener does the work
    }//GEN-LAST:event_langPickActionPerformed

    private void printButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_printButtonActionPerformed
        if (diagramExists) {
            Object[] btns = new Object[]{"Diagrams", "Horn Clauses"};
            Object ch = JOptionPane.showInputDialog(window,
                    se.getString("printWhat"),
                    se.getString("printOptions"),
                    JOptionPane.PLAIN_MESSAGE,
                    null,
                    btns, btns[0]);
            if (ch == null) {
                return;
            }
            if (((String)ch).equals("Diagrams")) {
                printDiagrams();
            }else {
                printHornClauses();
            }
            return;
        }  //  end of if-diagram-exists
        printHornClauses();
    }//GEN-LAST:event_printButtonActionPerformed

    /**Print whatever is currently diagrammed. Offer options re: how much to
     * print.
     */
    public void printDiagrams() {
        String chID = (String)chartComboBox.getSelectedItem();
        String allCharts = mi.getString("printAll"),
               visible = mi.getString("printVisible");
        Object[] btns = new Object[]{chID, visible, allCharts};
        Object ch = JOptionPane.showInputDialog(window,
                se.getString("printHowMuch"),
                se.getString("diagramPrintOptions"),
                JOptionPane.PLAIN_MESSAGE,
                null,
                btns, btns[0]);
        if (ch == null) {
            return;
        }
        PrintDiagram pd;
        if (((String)ch).equals(mi.getString("printVisible"))) {
            pd = new PrintDiagram(bottomPane, chart, false);
            pd.printTheChart();
        }else if(((String)ch).equals(chID)){
            pd = new PrintDiagram(bottomPane, chart, true);
            pd.printTheChart();
        } else {
            Iterator iter = chartEgos.keySet().iterator();
            while (iter.hasNext()) {
                chart.chartID = (String) iter.next();                
                pd = new PrintDiagram(bottomPane, chart, true);
                pd.printTheChart();
            }
        }
    }

    /**Give User a choice of what to print, and how much of it to print.
     * If she chooses to print all definitions, simply print out advice
     * on how to print a .thy file.
     * 
     */
    public void printHornClauses() {
        Object[] btns = new Object[]{se.getString("currentOnly"), 
            se.getString("allDefs") };
        Object ch = JOptionPane.showInputDialog(window,
                se.getString("printHowMuch"),
                se.getString("hornPrintOptions"),
                JOptionPane.PLAIN_MESSAGE,
                null,
                btns, btns[0]);
        if (ch == null) {
            return;
        }
        if (((String)ch).equals(se.getString("allDefs"))) {
            String advice = msgs.getString("advice1");
            advice += msgs.getString("advice2");
            advice += msgs.getString("advice3");
            advice += msgs.getString("advice4");
            advice += msgs.getString("advice5");
            advice += msgs.getString("advice6");
            advice += msgs.getString("advice7");
            JOptionPane.showMessageDialog(window, advice, msgs.getString("howPrintAll"),
                    JOptionPane.INFORMATION_MESSAGE);            
            return;
        }  //  otherwise print current definition        
        LibBrowserText lbText = new LibBrowserText(this);
        PrintHornClauses phc = new PrintHornClauses(lbText, this);
        phc.printTheHCs();
    }

    /**
     <p>The DomThListener class creates an ActionListener that listens for actions in the
     'Choose a Language' combo box.  When an action fires, read the selection and interpret it as 
     a specific domain theory.</p>
     <p>
     For example: For the language 'English' the convention is that "English" means terms of reference, 
     and "English(Adr)" means terms of address.  The context is loaded from its .ctxt file, 
     and the kinTerms of the chosen type (Ref or Adr) are loaded into the 'Choose a Kinship Term' combo box menu.</p>
     */
    public class DomThListener implements ActionListener  {
  
        public void actionPerformed(ActionEvent event) {
            if (langLoad) {
                return;
            }
            chart.noRefresh = true;
            String language = (String) langPick.getSelectedItem();
            String fileName = Library.libraryCtxtDirectory;
            boolean errors = false;
            Context priorContext = currentContext;  //  So we can revert to priors if 
            DomainTheory priorDT = currentDomTh;   //  the new one hits errors.
            //  If the selected item is "<langName>(Adr)" then we want terms of address
            int adrFlag = language.indexOf("(Adr)");
            if (adrFlag == -1) {
                adrFlag = language.length();
            }
            fileName += language.substring(0, adrFlag) + ".ctxt";
            langName = language;
            Context actxt = (Context) Library.activeContexts.get(language.substring(0, adrFlag));
            try {
                if (actxt != null) {  //  this-language-is-an-active-context
                    currentContext = actxt;
                    Context.current = currentContext;
                } else {
                    currentContext = Library.readContextFromDisk(fileName);  //  load it from disk
                    Context.current = currentContext;
                }
                if (adrFlag == language.length()) //  Reference terms are selected
                {
                    currentDomTh = currentContext.domTheoryRef();
                } else {
                    currentDomTh = currentContext.domTheoryAdr();
                }
                DomainTheory.current = currentDomTh;
                if (currentContext.individualCensus.size() > 0) {
                    currEgo = (Individual) currentContext.individualCensus.get(0);
                }
                //  Msgs intended for developer. Not translated.
            } catch (IOException jse) {
                JOptionPane.showMessageDialog(desktop,
                        "PROBLEM: Error loading " + fileName + ".\n" + prettify(jse.toString())
                        + "\nRECOMMENDATION: Check for disk, directory, or permissions problems.",
                        "File System Error",
                        JOptionPane.ERROR_MESSAGE);
                errors = true;
            } catch (ClassNotFoundException jse) {
                JOptionPane.showMessageDialog(desktop,
                        "PROBLEM: Internal Error: " + prettify(jse.toString())
                        + "\nRECOMMENDATION: Submit Bug Report.",
                        "Kinship System Error",
                        JOptionPane.ERROR_MESSAGE);
                errors = true;
            } catch (Exception e) {
                JOptionPane.showMessageDialog(desktop,
                        "PROBLEM: Internal Error: " + prettify(e.toString())
                        + "\nRECOMMENDATION: Submit Bug Report.",
                        "Kinship System Error",
                        JOptionPane.ERROR_MESSAGE);
                errors = true;
            }
            if (errors) {
                langLoad = true;
                langPick.setSelectedItem(priorLangPick);
                langLoad = false;
                if (priorContext != null) {
                    currentContext = priorContext;  //  Revert to priors.
                    Context.current = priorContext;
                    System.out.println("3  Current context reset to " + Context.current.languageName);
                    currentDomTh = priorDT;
                    DomainTheory.current = priorDT;
                }
                return;
            }
            //  If we got this far, theory has been loaded or made current without any problems.
            currentContext.libraryBrowsing = true;
            Library.currentLanguage = (String)langPick.getSelectedItem();
            priorLangPick = (String)langPick.getSelectedItem();
            String oldWinNum = windowNum;
            windowNum += "    " + langName;
            setTitle(windowNum);
            MainPane.topPane.updateViewMenu(oldWinNum, windowNum);
            //  At this point, we Load the Term menu
            termLoad = true;
            termPick.removeAllItems();  //  clear any items from Term menu
            int ctr = 0;
            Iterator termIter = currentDomTh.theory.keySet().iterator();
            while (termIter.hasNext())  { //  re-build term menu
                termPick.addItem(termIter.next());
                ctr++;
            }
            termLoad = false;
            if (ctr > 0) {
                termPick.setSelectedIndex(0);  //  make alphabetically-first term the selection
            }
            // Finally, make this the current context in the LibBrowserChart
            chart.currentContext = currentContext;
            try {
                currentContext.resetTo(0,0);
            }catch(Exception exc){
                // The section of code reached will not throw an exception.
            }
            chart.noRefresh = false;
        }  //  end of method actionPerformed  
        
    }  //  end of inner class DomThListener

    
    /**
     The KinTermListener class creates an ActionListener that listens for actions in the
     'Choose a Kin Term' combo box.  When an action fires, read the selection and interpret it as 
     a specific term.  Find the KinTermDef for that term and find out how many original and expanded
     clauses it contains.  Then create the items for the Clause and Expansion menus.
     */
    public class KinTermListener implements ActionListener  {
        
        public void actionPerformed(ActionEvent event) {
            if (termLoad) return;
            chart.noRefresh = true;
            String term = (String)termPick.getSelectedItem(); 
            termName = term;
            setTitle(windowNum + ": " + termName);
            currentKTD = (KinTermDef)currentDomTh.theory.get(term);
			//  Create the 'Choose a Clause' menu items
            int nmbrCBs = currentKTD.definitions.size();
            ClauseBody cb;
            clauseLoad = true;
            clausePick.removeAllItems();  //  clear any items from Clause menu
            clausePick.addItem(se.getString("all"));
            for (int i=0; i < nmbrCBs; i++) {
                cb = (ClauseBody)currentKTD.definitions.get(i);
                if (((cb.flags.contains("ext")) && (inclExt)) 
                    || ((! cb.flags.contains("ext")) && (inclPrim)))
                    clausePick.addItem(String.valueOf(i));
            }
            clauseLoad = false;
            currentOriginalHC = null;
            //  Create the 'Choose an Expansion' menu items
            nmbrCBs = currentKTD.expandedDefs.size();
            expLoad = true;
            expanPick.removeAllItems();  //  clear any items from Expansion menu
            expanPick.addItem(se.getString("all")); 
            for (int i=0; i < nmbrCBs; i++) {
                cb = (ClauseBody)currentKTD.expandedDefs.get(i);
                if (((cb.flags.contains("ext")) && (inclExt)) 
                    || ((! cb.flags.contains("ext")) && (inclPrim)))
                    expanPick.addItem(String.valueOf(i));
            }
            expLoad = false;
            currentExpandedHC = null;
            //  Make "All" the default selections for Clause & Expansion
            clausePick.setSelectedIndex(0); 
            expanPick.setSelectedIndex(0); 
            chart.noRefresh = false;
        }  //  end of method actionPerformed        
        
    }  //  end of inner class KinTermListener
    
     /**
     The ChartComboListener class creates an ActionListener that listens for actions in the
     chart combo box.
     */
    public class ChartComboListener implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            String item = (String) chartComboBox.getSelectedItem();
            int colon = item.indexOf(": ");
            if (colon != -1) {
                chart.chartID = item.substring(0, colon);
                int[] dims = dimensions.get(chart.chartID);
                chart.width = dims[0];
                chart.height = dims[1];
//                chart.writeLtrLegend = false;
                chart.repaint();
                bottomPane.scrollRectToVisible(new Rectangle(0, 0, 200, 200));
            } else { // Must be 'Edit Descriptions'
                String ch = chart.chartID;
                String msg = Library.messages.getString("newChartDescription") + " " + ch + ":";
                String newDescription = JOptionPane.showInputDialog(window, msg);
                if (newDescription != null) {
                    int ndxReset = 0;
                    ComboBoxModel model = chartComboBox.getModel();
                    int size = model.getSize();
                    String[] newItems = new String[size];
                    for (int i = 0; i < size; i++) {
                        item = (String) model.getElementAt(i);
                        if (item.startsWith(ch + ": ")) {
                            newItems[i] = ch + ": " + newDescription;
                            ndxReset = i;
                        } else {
                            newItems[i] = item;
                        }
                    }
                    comboItems = newItems;
                    chartComboBox.setModel(new DefaultComboBoxModel(newItems));
                    chartComboBox.setSelectedIndex(ndxReset);
                }
            }
        }
    }  //  end of inner class ChartComboListener

    /**
     * The ClauseListener class creates an ActionListener that listens for
     * actions in the 'Choose a Clause' combo box. When an action fires, read
     * the selection and interpret it as a specific clause.
     */
    public class ClauseListener implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            if (clauseLoad) {
                return;
            }
            chart.noRefresh = true;
            String clauseNumString = (String) clausePick.getSelectedItem();
            if (clauseNumString.equals(se.getString("all"))) {
                originalText.setText(currentKTD.toString("original", inclPrim, inclExt));
                originalText.setCaretPosition(0);
                currentOriginalHC = null;
            } else {  //  a-specific-clause-was-selected
                //  Display the selected Original clause in the OriginalText display
                int clauseNmbr = Integer.parseInt(clauseNumString);
                currentOriginalHC = (ClauseBody) currentKTD.definitions.get(clauseNmbr);
                originalText.setText(currentKTD.clauseHead.toString() + " :- ");
                originalText.append(currentOriginalHC.toString());
                originalText.setCaretPosition(0);
            }  //  end of a-specific-clause-was-selected
            //  Re-build the 'Choose an Expansion' menu to show only expansions of 
            //  the selected original clause.  
            expLoad = true;
            String oldChoice = (String) expanPick.getSelectedItem();
            expanPick.removeAllItems();  //  clear any items from Expansion menu
            expanPick.addItem(se.getString("all"));
            int nmbrCBs = currentKTD.expandedDefs.size();
            ClauseBody cb;
            for (int i = 0; i < nmbrCBs; i++) {
                cb = (ClauseBody) currentKTD.expandedDefs.get(i);
                if ((((cb.flags.contains("ext")) && (inclExt))
                        || ((!cb.flags.contains("ext")) && (inclPrim)))
                        && (cb.isExpansionOf(currentOriginalHC))) {
                    expanPick.addItem(String.valueOf(i));
                }
            }  //  end of loop thru all expandedDefs
            //  If the current command for an expansion is an expansion of the selected original clause, 
            //  then keep it.  Otherwise, change the command to 'All' (which means "all expansions of the
            //  selected original clause").
            if ((currentExpandedHC == null) || (!currentExpandedHC.isExpansionOf(currentOriginalHC))) {
                    //  Current command is "All" or not an expansion of the selected original clause
                //  Ergo, must change command to 'All'
                expLoad = false;
                currentExpandedHC = null;
                expanPick.setSelectedIndex(0);
            } else {  //  Current command is an expansion of the selected original clause.  Keep it.
                expanPick.setSelectedItem(oldChoice);
                expLoad = false;
            }  //  end of 'Keep it'
            // originalSP.getVerticalScrollBar().setValue(0);
            originalText.setCaretPosition(0);
            //  Either way, re-set scroll bar to top
            chart.noRefresh = false;
        }  //  end of method actionPerformed        

    }  //  end of inner class ClauseListener
    
    /**
        The ExpListener class creates an ActionListener that listens for actions in the
     'Choose an Expansion' combo box.  When an action fires, read the selection and interpret it as 
     a specific expansion clause.
     */
    public class ExpListener implements ActionListener  {

        public void actionPerformed(ActionEvent event) {
            if (expLoad) {
                return;
            }
            chart.noRefresh = true;
            String expanseNumString = (String) expanPick.getSelectedItem();
            String clauseNumString = (String) clausePick.getSelectedItem(), nxt;
            if ((expanseNumString.equals(se.getString("all"))) //  'All' in both -- print everything
                    && (clauseNumString.equals(se.getString("all")))) {
                expandedText.setText(currentKTD.toString("expanded", inclPrim, inclExt));
                expandedText.setCaretPosition(0);
            } else if (expanseNumString.equals(se.getString("all"))) {  // specific original; 'All' expansions of it
                int nmbrCBs = currentKTD.expandedDefs.size();
                ClauseBody cb;
                expandedText.setText("");
                for (int i = 0; i < nmbrCBs; i++) {
                    cb = (ClauseBody) currentKTD.expandedDefs.get(i);
                    if ((((cb.flags.contains("ext")) && (inclExt))
                            || ((!cb.flags.contains("ext")) && (inclPrim)))
                            && (cb.isExpansionOf(currentOriginalHC))) {
                        if (i < 9) {
                            expandedText.append(String.valueOf(i) + "   ");
                        } else {
                            expandedText.append(String.valueOf(i) + "  ");
                        }
                        expandedText.append(cb.toString() + "\n");
                    }  //  end of if-it's-the-right-flavor
                }  // end of for-all-expanded-definitions
                expandedText.setCaretPosition(0);
            } else {  //  specific-expanded-clause-is-selected
                int clauseNmbr = Integer.parseInt(expanseNumString);
                currentExpandedHC = (ClauseBody) currentKTD.expandedDefs.get(clauseNmbr);
                expandedText.setText(currentKTD.clauseHead.toString() + " :- ");
                expandedText.append(currentExpandedHC.toString());
                expanded.getVerticalScrollBar().setValue(0);
            }  //  end of specific-clause-is-selected
            chart.noRefresh = false;
        }  //  end of method actionPerformed  
        
    }  //  end of inner class ExpListener

    /**
     * The PrimExtListener class creates an ActionListener that listens for
     * actions in the 'Primary/Extended/Both ' radio buttons. When an action
     * fires, update the booleans on the picker that record which types of
     * clauses should be displayed. Then trigger updates of the menus 'Choose a
     * Clause.' and 'Choose an Expansion.'
     */
    public class PrimExtListener implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            String command = (String) event.getActionCommand();
            // set the boolean flags based on which button is selected
            if ((command.equals("Both")) || (command.equals("Primary"))) {
                inclPrim = true;
            } else {
                inclPrim = false;
            }
            if ((command.equals("Both")) || (command.equals("Extended"))) {
                inclExt = true;
            } else {
                inclExt = false;
            }
            //  Now trigger re-building of the clause menus by setting a value
            chart.noRefresh = true;
            int ndx = termPick.getSelectedIndex();
            termPick.setSelectedIndex(ndx);
            chart.noRefresh = false;
        }  //  end of method actionPerformed        

    }  //  end of inner class PrimExtListener

    /**
     * The DiagramButtonListener class creates an ActionListener that listens
     * for clicks on the 'Diagram Examples' button. When an action fires, launch
 a TermChooserFrame to collect the commands that record which clauses
 should be diagramed. When User has finished using that frame, it will
 build a list of TermTriples for her commands. Then the TermChooserFrame
 will call LibBrowser.diagramTerms() to create a hypothetical population
 which illustrates the chosen term/clause -- and diagram it.
     */
    public class DiagramButtonListener implements ActionListener {

        public void actionPerformed(ActionEvent event) {
            //  Allow User to pick one or more terms (actually, 
            //  kinTerm-Clause-Expansion triples) to diagram. Then proceed to
            //  generate examples of those clauses. Finally, diagram the entire
            //  population of the context.
            chart.noRefresh = true;
            if (currentContext == null || currentDomTh == null) {
                JOptionPane.showMessageDialog(window,
                        msgs.getString("firstChooseLang"),
                        msgs.getString("diagramWhat?"), 
                        JOptionPane.ERROR_MESSAGE);
                return;
            }
            Context.current = currentContext;  //  so that the diagram methods can access context
            DomainTheory.current = currentDomTh;  //  and domTh fields.
            TermChooserFrame picker = new TermChooserFrame(currentDomTh, window);
            picker.desktop = desktop;
            picker.setLocation(100, 150);
            desktop.add(picker);
            picker.show();
            picker.moveToFront();
            try {
                picker.setSelected(true);
            } catch (PropertyVetoException pv) {
            }  //  Won't happen.  
            chart.noRefresh = false;
        }  //  end of method actionPerformed 

//  Used for Testing Only
        void printPopulationSummary() {
            // For debug only.
            for(Link lk : currentContext.linkCensus) {
                Individual i = lk.personPointedTo;
                String nam = (i.name.equals("Ego") ? " *" : "");
                System.out.println(lk.serialNmbr + nam + "\t(" + i.gender + ") \t" +
                        lk.homeChart + " \tpoints to: " + i.serialNmbr + " on chart "
                + i.homeChart);
            }
            for (Individual i : currentContext.individualCensus) {
                String spouse = "none";
                if (! i.marriages.isEmpty()) {
                    Family fam = (Family) i.marriages.get(0);
                    if(fam.husband == i) {
                        spouse = "#" + fam.wife.serialNmbr;
                    }else{
                        spouse = "#" + fam.husband.serialNmbr;
                    }
                }
                String bFam = (i.birthFamily == null ? "none" : 
                        "#" + i.birthFamily.serialNmbr);
                String nam = (i.name.equals("Ego") ? " *" : "");
                System.out.println(i.serialNmbr + nam + "\t(" + i.gender + ") \t" +
                        i.homeChart + " \tSpouse: " + spouse + " \tB-Fam: "
                + bFam);
            }
        }
}  //  end of inner class DiagramButtonListener

    
    /**This inner class is a convenience; it holds a kin term, its base clause 
     * number, and its expanded defs clause number. 
     */
    public static class TermTriple {
        String kinTerm;
        int baseClauseNmbr, expClauseNmbr;
        
        public TermTriple(String kTerm, int base, int exp) {
            kinTerm = kTerm;
            baseClauseNmbr = base;
            expClauseNmbr = exp;
        }
        
        public boolean equals(TermTriple t2) {
            if (kinTerm.equals(t2.kinTerm) &&
                    baseClauseNmbr == t2.baseClauseNmbr &&
                    expClauseNmbr == t2.expClauseNmbr) {
                return true;
            }
            return false;
        }
        
        public String toString() {
            String base = (baseClauseNmbr == -1 ? se.getString("all") 
                    : String.valueOf(baseClauseNmbr));
            String exp = (expClauseNmbr == -1 ? se.getString("all") 
                    : String.valueOf(expClauseNmbr));
            return kinTerm + " - " + base + " - " + exp;
        }
        
        public static TermTriple readFromString(String input) {
            int locus1 = input.indexOf(" - "),
                locus2 = input.lastIndexOf(" - ");
            String kTerm = input.substring(0,locus1);
            String clause1 = input.substring(locus1 +3, locus2),
                   clause2 = input.substring(locus2 +3);
            int basNmbr, exNmbr;
            if (clause1.equals(se.getString("all"))) {
                basNmbr = -1;
            }else {
                basNmbr = Integer.parseInt(clause1);
            }
            if (clause2.equals(se.getString("all"))) {
                exNmbr = -1;
            }else {
                exNmbr = Integer.parseInt(clause2);
            }
            return new TermTriple(kTerm, basNmbr, exNmbr);
        }
    }  //  end of inner class TermTriple

    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane bottomPane;
    private javax.swing.JComboBox chartComboBox;
    private javax.swing.JComboBox clausePick;
    private javax.swing.JTextArea diagram;
    private javax.swing.JButton diagramIt;
    private javax.swing.JComboBox expanPick;
    private javax.swing.JScrollPane expanded;
    private javax.swing.JTextArea expandedText;
    private javax.swing.JComboBox langPick;
    private javax.swing.JScrollPane original;
    private javax.swing.JTextArea originalText;
    private javax.swing.JButton printButton;
    private javax.swing.JRadioButton rbBoth;
    private javax.swing.JRadioButton rbExt;
    private javax.swing.JRadioButton rbPrim;
    private javax.swing.ButtonGroup rbPrimExt;
    private javax.swing.JSplitPane splitPane;
    private javax.swing.JComboBox termPick;
    // End of variables declaration//GEN-END:variables
}
