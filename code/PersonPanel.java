

import java.text.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;

/**
 * This class is part of the SILKin program's GUI. It is modeled after the
 * KAES KinshipEditor by Michael D. Fischer of the Centre for Social
 * Anthropology and Computing, University of Kent.
 * Those portions taken from his code are copyrighted by him; all rights
 * reserved. See his complete copyright statement and terms of re-use in
 * e.g. KinshipEditor.java in this package.
 *
 * DATA POSTING STRATEGY - As soon as any field in this panel loses focus, we
 * post the latest data to the Individual/Person being displayed ("infoPerson").
 * When a new person is chosen for display, we validate all data and if any
 * invalid fields are found, we do not allow the change in infoPerson until
 * valid data is entered. Then the person's record is updated and we proceed to
 * let user choose a new infoPerson to display/edit.
 *
 * @author Gary Morris, University of Pennsylvania
 */
public class PersonPanel extends javax.swing.JPanel {

    /** Creates new form PersonPanel */
    public PersonPanel() {
        initComponents();
        parent = SIL_Edit.editWindow;
        alterID.setColumns(3);
        confirmKT.setVisible(false);
        confirmRKT.setVisible(false);
        confirmKTAdr.setVisible(false);
        confirmRKTAdr.setVisible(false);
        alterRefTerm.setEditable(false);
        recipRefTerm.setEditable(false);
        egoChoiceModel = (DefaultComboBoxModel)egoChoiceBox.getModel();
        egoChoiceModel.removeAllElements();  //  ready for first person
        personComments.getDocument().addDocumentListener(new CommentListener());
//        buildFocusFields();
    }

    SIL_Edit parent = null;  //  The container holding this JPanel.
    String kinterm = null,
           reciprocalKinTerm = null;
    DefaultComboBoxModel egoChoiceModel;

    boolean dirty = false;  //  This 'dirty bit' applies only to the current
                            //  infoPerson.
    boolean storing = false;  // true when storing info on Person
    boolean birthDateNormallyCaptured = false,
            surnameNormallyCaptured = true;

    static String alterKinTermRefImg, alterKinTermAdrImg, recipKinTermRefImg, recipKinTermAdrImg;
    JTextField[] focusFields;

    void buildFocusFields() {
        int size = 3, ndx = 0;
        if (surnameNormallyCaptured) size++;
        if (birthDateNormallyCaptured) size++;
        if (parent.chart.distinctAdrTerms) size += 2;
        focusFields = new JTextField[size];
        focusFields[ndx++] = alterFirstNames;
        if (surnameNormallyCaptured) {
            focusFields[ndx++] = alterLastName;
        }
        if (birthDateNormallyCaptured) {
            focusFields[ndx++] = personBirthYr;
        }
        focusFields[ndx++] = alterRefTerm;
        focusFields[ndx++] = recipRefTerm;
        if (parent.chart.distinctAdrTerms) {
            focusFields[ndx++] = alterAdrTerm;
            focusFields[ndx++] = recipAdrTerm;
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        alterFirstNames = new javax.swing.JTextField();
        alterLastName = new javax.swing.JTextField();
        egoPanel = new javax.swing.JPanel();
        egoChoiceBox = new javax.swing.JComboBox();
        jLabel5 = new javax.swing.JLabel();
        alterID = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        personBirthMM = new javax.swing.JTextField();
        personBirthYr = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        personDeathYear = new javax.swing.JTextField();
        personDeathMon = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        alterRefTerm = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        recipRefTerm = new javax.swing.JTextField();
        confirmKT = new javax.swing.JCheckBox();
        confirmRKT = new javax.swing.JCheckBox();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        alterAdrTerm = new javax.swing.JTextField();
        recipAdrTerm = new javax.swing.JTextField();
        confirmKTAdr = new javax.swing.JCheckBox();
        confirmRKTAdr = new javax.swing.JCheckBox();
        jScrollPane1 = new javax.swing.JScrollPane();
        personComments = new javax.swing.JTextPane();
        bornYrLabel = new javax.swing.JLabel();
        personBirthDD = new javax.swing.JTextField();
        personDeathDD = new javax.swing.JTextField();

        setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Current Alter", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 0, 13), new java.awt.Color(0, 0, 204))); // NOI18N
        setMaximumSize(new java.awt.Dimension(907, 309));
        setMinimumSize(new java.awt.Dimension(907, 309));

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel1.setText("Name");
        jLabel1.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);

        alterFirstNames.setEditable(false);
        alterFirstNames.setText("first names");
        alterFirstNames.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterFirstNamesFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterFirstNamesFocusLost(evt);
            }
        });

        alterLastName.setEditable(false);
        alterLastName.setText("last name");
        alterLastName.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterLastNameFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterLastNameFocusLost(evt);
            }
        });

        egoPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Current Ego", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 1, 10), new java.awt.Color(255, 0, 51))); // NOI18N

        egoChoiceBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        egoChoiceBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                egoChoiceBoxActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout egoPanelLayout = new org.jdesktop.layout.GroupLayout(egoPanel);
        egoPanel.setLayout(egoPanelLayout);
        egoPanelLayout.setHorizontalGroup(
            egoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(egoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(egoChoiceBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 321, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        egoPanelLayout.setVerticalGroup(
            egoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(egoChoiceBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );

        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel5.setText("ID#");

        alterID.setEditable(false);
        alterID.setText("nnn");
        alterID.setMinimumSize(new java.awt.Dimension(100, 28));

        jLabel8.setText("Born:");

        personBirthMM.setColumns(2);
        personBirthMM.setEditable(false);
        personBirthMM.setText("MM");
        personBirthMM.setMaximumSize(new java.awt.Dimension(64, 28));
        personBirthMM.setMinimumSize(new java.awt.Dimension(64, 28));
        personBirthMM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                personBirthMMActionPerformed(evt);
            }
        });

        personBirthYr.setColumns(4);
        personBirthYr.setEditable(false);
        personBirthYr.setText("YYYY");
        personBirthYr.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personBirthYrFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                personBirthYrFocusLost(evt);
            }
        });

        jLabel12.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel12.setText("Notes on Alter");

        personDeathYear.setColumns(4);
        personDeathYear.setEditable(false);
        personDeathYear.setText("YYYY");
        personDeathYear.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personDeathYearFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                personDeathYearFocusLost(evt);
            }
        });

        personDeathMon.setColumns(2);
        personDeathMon.setEditable(false);
        personDeathMon.setText("MM");
        personDeathMon.setMaximumSize(new java.awt.Dimension(73, 28));
        personDeathMon.setMinimumSize(new java.awt.Dimension(64, 28));

        jLabel9.setText("Died:");

        jLabel10.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel10.setText("Ego refers to Alter:");

        alterRefTerm.setEditable(false);
        alterRefTerm.setText("kin term");
        alterRefTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterRefTermFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterRefTermFocusLost(evt);
            }
        });

        jLabel11.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel11.setText("Alter refers to Ego:");

        recipRefTerm.setEditable(false);
        recipRefTerm.setText("reciprocal kin term");
        recipRefTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                recipRefTermFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                recipRefTermFocusLost(evt);
            }
        });

        confirmKT.setText("Confirm");
        confirmKT.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                confirmKTItemStateChanged(evt);
            }
        });

        confirmRKT.setText("Confirm");
        confirmRKT.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                confirmRKTItemStateChanged(evt);
            }
        });

        jLabel2.setText("Ego addresses Alter:");

        jLabel3.setText("Alter addresses Ego:");

        alterAdrTerm.setEditable(false);
        alterAdrTerm.setText("kin term of address");
        alterAdrTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterAdrTermFocusGained(evt);
            }
        });

        recipAdrTerm.setEditable(false);
        recipAdrTerm.setText("reciprocal term of address");
        recipAdrTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                recipAdrTermFocusGained(evt);
            }
        });

        confirmKTAdr.setText("Confirm");

        confirmRKTAdr.setText("Confirm");

        jScrollPane1.setViewportView(personComments);

        bornYrLabel.setText("Yr");

        personBirthDD.setColumns(2);
        personBirthDD.setText("DD");
        personBirthDD.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                personBirthDDActionPerformed(evt);
            }
        });
        personBirthDD.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personBirthDDFocusGained(evt);
            }
        });

        personDeathDD.setColumns(2);
        personDeathDD.setText("DD");
        personDeathDD.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personDeathDDFocusGained(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                                .add(15, 15, 15)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 38, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel5))
                                .add(2, 2, 2)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(layout.createSequentialGroup()
                                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                                                .add(alterID, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                                .add(19, 19, 19)
                                                .add(jLabel8))
                                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel9))
                                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                        .add(bornYrLabel)
                                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                                            .add(personDeathYear)
                                            .add(personBirthYr))
                                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                                            .add(personDeathMon, 0, 0, Short.MAX_VALUE)
                                            .add(personBirthMM, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 40, Short.MAX_VALUE))
                                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                            .add(personDeathDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                            .add(personBirthDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                                    .add(layout.createSequentialGroup()
                                        .add(alterFirstNames, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 159, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                        .add(2, 2, 2)
                                        .add(alterLastName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 119, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 160, Short.MAX_VALUE))
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel10)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel11)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel2)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel3))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(alterRefTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                                    .add(recipRefTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                                    .add(alterAdrTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                                    .add(recipAdrTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(confirmKT)
                                    .add(confirmRKT)
                                    .add(confirmKTAdr)
                                    .add(confirmRKTAdr))))
                        .add(13, 13, 13)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createSequentialGroup()
                                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 347, Short.MAX_VALUE)
                                .add(20, 20, 20))
                            .add(egoPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(jLabel12)
                        .add(165, 165, 165))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(11, 11, 11)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                                .add(org.jdesktop.layout.GroupLayout.LEADING, alterFirstNames)
                                .add(org.jdesktop.layout.GroupLayout.LEADING, alterLastName))
                            .add(jLabel1))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel5)
                            .add(alterID, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(jLabel8)
                            .add(bornYrLabel)
                            .add(personBirthYr, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personBirthMM, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personBirthDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel9)
                            .add(personDeathYear, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personDeathMon, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personDeathDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel10)
                            .add(alterRefTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(confirmKT))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                                .add(jLabel11)
                                .add(recipRefTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                            .add(confirmRKT))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel2)
                            .add(alterAdrTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(confirmKTAdr))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel3)
                            .add(recipAdrTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(confirmRKTAdr)))
                    .add(layout.createSequentialGroup()
                        .add(egoPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                        .add(jLabel12)
                        .add(15, 15, 15)
                        .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 164, Short.MAX_VALUE)))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

//  DATA CAPTURE STRATEGY
//  This panel's 'dirty bit' records whether any data has been entered on the
//  panel but not yet stored on the Family/Marriage object.
//  The KinEditPanel2's dirty bit, by contrast, records whether any objects
//  have been updated but not yet saved to disk.
//  The panel dirty bit is turned on whenever an editable field gains the
//  focus. If that field later loses the focus, a data store is triggered.
//  But if the user takes some other action that does NOT fire a Focus_Lost
//  event, the dirty bit will prevent loss of data.

    private void alterFirstNamesFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterFirstNamesFocusLost
        String s = alterFirstNames.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.firstNames == null || ! parent.infoPerson.firstNames.equals(s)) {
                parent.infoPerson.firstNames = s;
                parent.infoPerson.updateNames();
                dirty = true;
            }
        }
    }//GEN-LAST:event_alterFirstNamesFocusLost

    private void alterLastNameFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterLastNameFocusLost
        String s = alterLastName.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.surname == null || ! parent.infoPerson.surname.equals(s)) {
                parent.infoPerson.surname = s;
                parent.infoPerson.updateNames();
                dirty = true;
            }
        }
    }//GEN-LAST:event_alterLastNameFocusLost

    private void personBirthYrFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthYrFocusLost
        //  Entries are not validated until a new Person/Family is clicked.
        String s =  personBirthYr.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.birthYr == null || ! parent.infoPerson.birthYr.equals(s)) {
                parent.infoPerson.birthYr = s;
                dirty = true;
            }
        }
    }//GEN-LAST:event_personBirthYrFocusLost

    private void personDeathYearFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathYearFocusLost
        //  Entries are not validated until a new Person/Family is clicked.
        String s =  personDeathYear.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.deathYr == null || ! parent.infoPerson.deathYr.equals(s)) {
                parent.infoPerson.deathYr = s;
                dirty = true;
            }
        }
    }//GEN-LAST:event_personDeathYearFocusLost

    private void confirmKTItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_confirmKTItemStateChanged
        // TODO confirm the system-generated kinTerm
        // This btn is a flag to allow User to change focus to another person.
        // If kinTerm is not confirmed or edited, PopUp an error dialog box.
    }//GEN-LAST:event_confirmKTItemStateChanged

    private void confirmRKTItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_confirmRKTItemStateChanged
        // TODO confirm the system-generated kinTerm
        // This btn is a flag to allow User to change focus to another person.
        // If recip kinTerm is not confirmed or edited, PopUp an error dialog box.
    }//GEN-LAST:event_confirmRKTItemStateChanged

    private void alterRefTermFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterRefTermFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_alterRefTermFocusLost

    private void recipRefTermFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipRefTermFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_recipRefTermFocusLost

    private void alterFirstNamesFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterFirstNamesFocusGained
        dirty = true;
    }//GEN-LAST:event_alterFirstNamesFocusGained

    private void alterLastNameFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterLastNameFocusGained
        dirty = true;
    }//GEN-LAST:event_alterLastNameFocusGained

    private void personBirthYrFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthYrFocusGained
        dirty = true;
    }//GEN-LAST:event_personBirthYrFocusGained

    private void personDeathYearFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathYearFocusGained
        dirty = true;
    }//GEN-LAST:event_personDeathYearFocusGained

    private void alterRefTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterRefTermFocusGained
        dirty = true;
    }//GEN-LAST:event_alterRefTermFocusGained

    private void recipRefTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipRefTermFocusGained
        dirty = true;
    }//GEN-LAST:event_recipRefTermFocusGained

    private void egoChoiceBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_egoChoiceBoxActionPerformed
        if (! storing) {
            parent.changeEgo(egoChoiceBox.getSelectedIndex());
        }
    }//GEN-LAST:event_egoChoiceBoxActionPerformed

    private void alterAdrTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterAdrTermFocusGained
        dirty = true;
    }//GEN-LAST:event_alterAdrTermFocusGained

    private void recipAdrTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipAdrTermFocusGained
        dirty = true;
    }//GEN-LAST:event_recipAdrTermFocusGained

    private void personBirthMMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_personBirthMMActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_personBirthMMActionPerformed

    private void personBirthDDActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_personBirthDDActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_personBirthDDActionPerformed

    private void personDeathDDFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathDDFocusGained
        dirty = true;
    }//GEN-LAST:event_personDeathDDFocusGained

    private void personBirthDDFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthDDFocusGained
        dirty = true;
    }//GEN-LAST:event_personBirthDDFocusGained

    
    void clearInfo() {
        storing = true;
        alterFirstNames.setText("");
        alterLastName.setText("");
        alterID.setText("");
        personBirthDD.setText("");
        personDeathDD.setText("");
        personBirthMM.setText("");
        personDeathMon.setText("");
        personBirthYr.setText("");
        personDeathYear.setText("");
        personComments.setText("");
        alterRefTerm.setText("");
        recipRefTerm.setText("");
        alterAdrTerm.setText("");
        recipAdrTerm.setText("");
        alterRefTerm.setEditable(false);
        recipRefTerm.setEditable(false);
        alterAdrTerm.setEditable(false);
        recipAdrTerm.setEditable(false);
        alterFirstNames.setEditable(false);
        alterLastName.setEditable(false);
        personBirthMM.setEditable(false);
        personDeathMon.setEditable(false);
        personBirthYr.setEditable(false);
        personDeathYear.setEditable(false);
        personComments.setEditable(false);
        confirmKTAdr.setVisible(false);
        confirmRKTAdr.setVisible(false);
        confirmKT.setVisible(false);
        confirmRKT.setVisible(false);
        storing = false;
    }

    public void displayClues() {
        storing = true;
        alterFirstNames.setText("first names");
        alterLastName.setText("last name");
        alterID.setText("nnn");
        personBirthDD.setText("DD");
        personDeathDD.setText("DD");
        personBirthMM.setText("MM");
        personDeathMon.setText("MM");
        personBirthYr.setText("YYYY");
        personDeathYear.setText("YYYY");
        personComments.setText("");
        alterRefTerm.setText("kin term");
        recipRefTerm.setText("reciprocal kin term");
        alterAdrTerm.setText("kin term of address");
        recipAdrTerm.setText("reciprocal kin term of address");
        storing = false;
    }

    void showInfo(Individual ind) {
        storing = true;
        if (focusFields == null) buildFocusFields();
        alterFirstNames.setText(ind.firstNames);
        alterLastName.setText(ind.surname);
        alterID.setText(String.valueOf(ind.serialNmbr));
        personBirthDD.setText(ind.getBirthDD());
        personDeathDD.setText(ind.getDeathDD());
        personBirthMM.setText(ind.getBirthMM());
        personDeathMon.setText(ind.getDeathMM());
        personBirthYr.setText(ind.getBirthYr());
        personDeathYear.setText(ind.getDeathYr());
        personComments.setText(ind.comment);
        alterFirstNames.setEditable(true);
        alterLastName.setEditable(true);
        personBirthMM.setEditable(true);
        personDeathMon.setEditable(true);
        personBirthYr.setEditable(true);
        personDeathYear.setEditable(true);
        personComments.setEditable(true);
        if (ind.serialNmbr == parent.getCurrentEgo()) {
            alterRefTerm.setText("Ego");
            recipRefTerm.setText("Ego");
            alterAdrTerm.setText("Ego");
            recipAdrTerm.setText("Ego");
            alterRefTerm.setEditable(false);
            recipRefTerm.setEditable(false);
            alterAdrTerm.setEditable(false);
            recipAdrTerm.setEditable(false);
        } else if (ind.node != null) {
        // There may be kin terms already recorded
            fillTextField(ind.node, alterRefTerm, false);
            fillTextField(ind.node, alterAdrTerm, true);
            TreeMap tmap = parent.ktm.getRow(ind.serialNmbr);
            Node altNode = (Node) tmap.get(parent.getCurrentEgo());
            if (altNode != null) {
                fillTextField(altNode, recipRefTerm, false);
                fillTextField(altNode, recipAdrTerm, true);
            }else {
                recipRefTerm.setText("");
                recipAdrTerm.setText("");
            }
            alterRefTerm.setEditable(true);
            recipRefTerm.setEditable(true);
            alterAdrTerm.setEditable(parent.chart.distinctAdrTerms);
            recipAdrTerm.setEditable(parent.chart.distinctAdrTerms);

        } else {
        //  No node means not yet connected
            alterRefTerm.setText("not yet linked to Ego");
            recipRefTerm.setText("not yet linked to Ego");
            alterAdrTerm.setText("not yet linked to Ego");
            recipAdrTerm.setText("not yet linked to Ego");
            alterRefTerm.setEditable(false);
            recipRefTerm.setEditable(false);
            alterAdrTerm.setEditable(false);
            recipAdrTerm.setEditable(false);
        } // store images of 4 boxes before any User edits
        alterKinTermRefImg = alterRefTerm.getText();
        alterKinTermAdrImg = alterAdrTerm.getText();
        recipKinTermRefImg = recipRefTerm.getText();
        recipKinTermAdrImg = recipAdrTerm.getText();
        for (JTextField fld : focusFields) {
            if (fld.getText().equals("")) {
                fld.grabFocus();
                break;
            }
        }
        storing = false;
        // TODO turn on 'confirm' CkBox if kt is generated etc.
    }

    void fillTextField(Node nod, String fieldType, boolean addr) {
        JTextField field = null;
        if (fieldType.equals("primary")) {
            field = (addr ? alterAdrTerm : alterRefTerm);
        }else if (fieldType.equals("reciprocal")) {
            field = (addr ? recipAdrTerm : recipRefTerm);
        }
        fillTextField(nod, field, addr);
    }

    void fillTextField(Node nod, JTextField field, boolean addr) {
        ArrayList<String> terms = nod.getKinTerms(addr);
        if (terms.isEmpty()) {
            field.setText("");
        } else {
            String newText = "";
            int soFar = 0;
            for (String s : terms) {
                newText += (soFar++ == 0 ? "" : ", ") + s;
            }
            field.setText(newText);
        }
    }

    void storeInfo(Individual infoPerson) 
            throws KSParsingErrorException, JavaSystemException,
		   KSBadHornClauseException, KSInternalErrorException,
                   KSConstraintInconsistency, KSDateParseException {
	if (! dirty) return;  //  No changes have been made
        storing = true;
        String a, b, c;
        int nmbr, currEgoNum = parent.getCurrentEgo();
        Dyad newDyad;
        Individual currEgo =
                    Context.current.individualCensus.get(currEgoNum);
        a = alterFirstNames.getText().trim()
            + " " + alterLastName.getText().trim();
        if (! infoPerson.name.equals(a)) {
            infoPerson.name = a;
            infoPerson.surname = alterLastName.getText().trim();
            infoPerson.firstNames = alterFirstNames.getText().trim();
            parent.chart.dirty = true;            
        }
        if (! infoPerson.deleted) updateEgoNames(infoPerson);
        boolean ok = true;
        a = personBirthMM.getText().trim();
        if (a.length() == 1) a = "0"+ a;  // canonical form
        b = personBirthYr.getText().trim();
        c = personBirthDD.getText().trim();
        if (c.length() == 1) c = "0"+ c;
        if (! infoPerson.getDateOfBirth().equals(UDate.formatAsXSD(b, a, c))) {
            ok = UDate.valiDate(b, a, c, infoPerson, false);
            if (! ok) {
                c = "Invalid date of birth: '" + b + "-" + a + "-" + c;
                throw new KSDateParseException(c);
            }
        }
        a = personDeathMon.getText().trim();
        if (a.length() == 1) a = "0"+ a;
        b = personDeathYear.getText().trim();
        c = personDeathDD.getText().trim();
        if (c.length() == 1) c = "0"+ c;
        if (! infoPerson.getDateOfDeath().equals(UDate.formatAsXSD(b, a, c))) {
            ok = UDate.valiDate(b, a, c, infoPerson, true);
            if (! ok) {
                c = "Invalid date of death: '" + b + "-" + a + "-" + c;
                throw new KSDateParseException(c);
            }
        }
        //  The comments field is handled by a DocumentListner
        ArrayList<String> oldTerms, newTerms;
        if (infoPerson.node != null && infoPerson.serialNmbr != currEgoNum) {
            a = alterRefTerm.getText();
            if (!a.trim().equals(alterKinTermRefImg.trim())) { // alterKinTermRefImg = before User editing
                oldTerms = getKinTerms(alterKinTermRefImg);
                newTerms = getKinTerms(a);
                updateKinTerms(currEgo, infoPerson, infoPerson.node, oldTerms, newTerms, "Ref");
                if (!parent.chart.distinctAdrTerms) {
                    updateKinTerms(currEgo, infoPerson, infoPerson.node, oldTerms, newTerms, "Adr");
                }
            } // end of User must have edited alterKinTermsRef
            if (parent.chart.distinctAdrTerms) {
                // Must pick up the term of address, if any
                a = alterAdrTerm.getText();
                if (!a.trim().equals(alterKinTermAdrImg.trim())) {
                    oldTerms = getKinTerms(alterKinTermAdrImg);
                    newTerms = getKinTerms(a);
                    updateKinTerms(currEgo, infoPerson, infoPerson.node, oldTerms, newTerms, "Adr");
                }
            }  // end of there-were-distinct-address-terms
            a = recipRefTerm.getText();
            TreeMap tmap = parent.ktm.getRow(infoPerson.serialNmbr);
            Node recipNode = (Node) tmap.get(currEgoNum);
            if (!a.trim().equals(recipKinTermRefImg.trim())) {
                oldTerms = getKinTerms(recipKinTermRefImg);
                newTerms = getKinTerms(a);
                if (recipNode != null) {
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Ref");
                } else {  //  Must create the reciprocal node
                    recipNode = new Node();
                    recipNode.indiv = currEgo;
                    recipNode.setLevel(-1 * infoPerson.node.getLevel());
                    recipNode.addTerms(newTerms, "primary", "reference");
                    infoPerson.node.invertMiniPredsAndPCStringFor(recipNode);
                    parent.ktm.addNode(infoPerson.serialNmbr, currEgoNum, recipNode);
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Ref");
                }
                if (!parent.chart.distinctAdrTerms) {
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Adr");
                }  //  end of no-distinct-address-terms
            } //  end of recip-ref-terms-were-edited
            if (parent.chart.distinctAdrTerms) {
                // Must pick up the reciprocal term of address, if any
                a = recipAdrTerm.getText();
                if (!a.trim().equals(recipKinTermAdrImg.trim())) {
                    oldTerms = getKinTerms(recipKinTermAdrImg);
                    newTerms = getKinTerms(a);
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Adr");
                }  //  end of recip-address-terms-were-edited
            }  //  end of distinct-address-terms
        }  //  end of non-ego-has-a-node
        if (Library.currDataAuthor == null || Library.currDataAuthor.length() == 0) {
            b = "Name of data author?";
            Library.currDataAuthor = JOptionPane.showInputDialog(parent, b);
        }
        infoPerson.dataAuthor = Library.currDataAuthor;
        infoPerson.dataChangeDate = UDate.today();
        parent.chart.dirty = true;
        dirty = false;
        storing = false;
//  DEBUG CODE
    int ktmSz = Context.current.ktm.numberOfKinTerms(),
        ktmCells = Context.current.ktm.numberOfCells(),
        popSz = Context.current.indSerNumGen,
        refSz = DomainTheory.countLeaves(Context.current.domTheoryRef().dyadsUndefined),
        adrSz = DomainTheory.countLeaves(Context.current.domTheoryAdr().dyadsUndefined);
    boolean dyadsBalanced = (refSz == adrSz),
            ktminBalance = (refSz + adrSz) == (ktmSz - (2 * popSz));
    if (!dyadsBalanced || !ktminBalance) {
        System.out.println("Ref dyads: " + refSz + "\tAdr dyads: " + adrSz + "\tktmTerms: " +
            ktmSz + " - " + (2 * popSz) + " = " + (ktmSz - (2 * popSz)) + "\tktmCells: " + ktmCells);
        Context.breakpoint();
        }
// END DEBUG CODE
    }

    static ArrayList<String> getKinTerms(String s) {
        ArrayList<String> list = new ArrayList<String>();
        s = s.trim();
        int comma = s.indexOf(","), start = 0, stop;
        while(comma > 0) {
            stop = (comma > 0 ? comma : s.length());
            list.add(s.substring(start, stop));
            start = stop +2;
            comma = s.indexOf(",", start);
        }
        if ((s.length() - start) > 0) {
            list.add(s.substring(start, s.length()));
        }
        return list;
    }

    
    static void updateKinTerms(Individual currEgo, Individual infoPerson, Node nod,
            ArrayList<String> oldTerms, ArrayList<String> newTerms, String typ) {

        ArrayList<String> deletedTerms = new ArrayList<String>(),
                          addedTerms = new ArrayList<String>();
        for (String newbie : newTerms) {
            if (!oldTerms.contains(newbie)) {
                addedTerms.add(newbie);
            }
        }
        for (String oldie : oldTerms) {
            if (!newTerms.contains(oldie)) {
                deletedTerms.add(oldie);
            } // NOTE: In both the node and dyad, we assume (for now) that
        }     //       only primary terms are being captured. To be Reviewed.
        nod.replaceTerms(newTerms, "primary", (typ.equals("Ref") ? "reference" : "address"));
        try {
            DomainTheory dt = (typ.equals("Ref") ? Context.current.domTheoryRef()
                    : Context.current.domTheoryAdr());
            for (String term : addedTerms) {
                Dyad newDyad = makeDyad(currEgo, infoPerson, term, nod);
                if (dt.dyadsDefined.containsKey(term)) {
                    dt.dyadsDefined.dyAddOrUpdate(newDyad);
                } else {
                    dt.dyadsUndefined.dyAddOrUpdate(newDyad);
                }
            }
            for (String term : deletedTerms) {
                if (dt.dyadsDefined.containsKey(term)) {
                    dt.dyadsDefined.removeDyad(term, nod.pcString, currEgo, infoPerson, dt);
                } else {
                    dt.dyadsUndefined.removeDyad(term, nod.pcString, currEgo, infoPerson, dt);
                }
            }
        } catch (Exception exc) {
            System.err.println("Error while retrieving Domain Theory from disk:\n" + exc);
        }
    }

    public static Dyad makeDyad(Individual currEgo, Individual infoPerson, String kinTerm, Node alterNode) {
        Dyad d = new Dyad(currEgo);
        d.alter = infoPerson;
        d.level = alterNode.getLevel();
        d.kinTerm = kinTerm;
        d.kinTermType = Dyad.PRIMARY;
        d.addrOrRef = (DomainTheory.addrTerms ? Dyad.ADDR : Dyad.REF);
        d.pcString = alterNode.pcString;
        try {
            d.pcStringStructural = ClauseBody.structStr(d.pcString);
        } catch (KSInternalErrorException ie) {
            String msg = "Problem making structural PCString in PPanel.storeInfo:\n" + ie;
            MainPane.displayError(msg, "Internal Problem", JOptionPane.WARNING_MESSAGE);
        }
        d.makePath(alterNode.miniPreds, infoPerson);
        if (d.path.size() != (symbolCount(d.pcString) -1)) {
            String msg = "\nERROR: Path size incorrect.\nPath = " + d.path;
            msg += "\nPC String = " + d.pcString;
            msg += "\nEgo = #" + currEgo.serialNmbr;
            msg += "\nAlter = #" + infoPerson.serialNmbr;
            System.out.println(msg);     
            Context.breakpoint();
        }
        return d;
    }

    /** Count the number of capital letters and double-asterisks in the
     * PC String. Each is the start of a symbol like 'Fa' or 'Hbro' or '**'
     * which represents one of the standard macro relationships.
     *
     * @param pcString  the kin type, like 'FaBroWiMo'
     * @return  the count
     */
    public static int symbolCount(String pcString) {
        int cnt = 0;
        char ch;
        for (int i=0; i < pcString.length(); i++) {
            ch = pcString.charAt(i);
            if (Character.isJavaIdentifierStart(ch) &&
		Character.isUpperCase(ch)) { // Capital Ltr
                cnt++;
            }else if (ch == '*') { // double-asterisk
                ch = pcString.charAt(++i);
                if (ch != '*') {
                    String msg = "\nERROR: Single '*' found in a PC String.\n";
                    msg += "String = " + pcString;
                    System.out.println(msg);
                    Context.breakpoint();
                }else cnt++;
            }
        }
        return cnt;
    }

    public static String getSymbolNumber(int number, String pcString) {
        String symbol = null;
        int start = 0;
        for (int n=0; n <= number; n++) {
            symbol = firstSymbolOf(pcString.substring(start));
            start += symbol.length();
        }
        return symbol;
    }

    public static String firstSymbolOf(String pcString) {
        if (pcString.substring(0,2).equals("**")) {
            return "**";
        }
        char ch;
        for (int i=1; i < pcString.length(); i++) {
            ch = pcString.charAt(i);
            if ((Character.isJavaIdentifierStart(ch) && Character.isUpperCase(ch))
                    || ch == '*') {
                return pcString.substring(0, i);
            }
        } // If we get here,must have ben a single symbol
        return pcString;
    }

    void clearEgoBox() {
        egoChoiceBox.removeAllItems();
    }

    void rebuildEgoBox() {
        storing = true;
        egoChoiceBox.removeAllItems();
        String newName;
        for (Individual ind : Context.current.individualCensus) {
            newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
            egoChoiceModel.addElement(newName);
        }
        egoChoiceBox.setSelectedIndex(parent.getCurrentEgo());
        storing = false;
    }

    void addToEgoChoices(Individual ind) {
        String newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
        egoChoiceModel.addElement(newName);
        if (egoChoiceModel.getSize() == 1) {
            egoChoiceBox.setSelectedIndex(0);
            parent.changeEgo(0);
        }
    }

    void resetEgoBox(int egoNum) {
        egoChoiceBox.setSelectedIndex(egoNum);
    }

    void updateEgoNames(Individual ind) {
        int ndx = ind.serialNmbr;
        String newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
        if (ndx < egoChoiceModel.getSize()) {
            egoChoiceModel.removeElementAt(ndx);
        }
        egoChoiceModel.insertElementAt(newName, ndx);
        egoChoiceBox.setSelectedIndex(parent.getCurrentEgo());
    }

    void setDistinctAdrTerms(boolean val) {
        parent.chart.distinctAdrTerms = val;
        alterAdrTerm.setEditable(val);
        recipAdrTerm.setEditable(val);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField alterAdrTerm;
    private javax.swing.JTextField alterFirstNames;
    private javax.swing.JTextField alterID;
    private javax.swing.JTextField alterLastName;
    private javax.swing.JTextField alterRefTerm;
    private javax.swing.JLabel bornYrLabel;
    private javax.swing.JCheckBox confirmKT;
    private javax.swing.JCheckBox confirmKTAdr;
    private javax.swing.JCheckBox confirmRKT;
    private javax.swing.JCheckBox confirmRKTAdr;
    private javax.swing.JComboBox egoChoiceBox;
    private javax.swing.JPanel egoPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField personBirthDD;
    private javax.swing.JTextField personBirthMM;
    private javax.swing.JTextField personBirthYr;
    private javax.swing.JTextPane personComments;
    private javax.swing.JTextField personDeathDD;
    private javax.swing.JTextField personDeathMon;
    private javax.swing.JTextField personDeathYear;
    private javax.swing.JTextField recipAdrTerm;
    private javax.swing.JTextField recipRefTerm;
    // End of variables declaration//GEN-END:variables

    class CommentListener implements DocumentListener {

        public void insertUpdate(DocumentEvent e) {
            if (!storing) {
                if (parent.infoPerson != null) {
                    String txt = FamilyPanel.convertBannedCharacters(personComments.getText());
                    parent.infoPerson.comment = txt;
                    parent.chart.dirty = true;
                }
            }
        }

        public void removeUpdate(DocumentEvent e) {
            if (!storing) {
                if (parent.infoPerson != null) {
                    String txt = FamilyPanel.convertBannedCharacters(personComments.getText());
                    parent.infoPerson.comment = txt;
                    parent.chart.dirty = true;
                }
            }
        }

        public void changedUpdate(DocumentEvent e) {
            //Plain text components do not fire these events
        }
    }  // end of inner class CommentListener

}
